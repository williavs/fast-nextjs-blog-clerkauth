---
title: "VM Go Brrrr: A Homelab Disaster Story"
date: "2025-08-19"
category: "infrastructure"
tags: ["vm", "packer", "vagrant", "claude-code", "oauth", "automation"]
excerpt: "How I solved the OAuth token complexity problem with a dead-simple persistent VM approach using Packer and Vagrant"
---

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Badge } from '@/components/ui/badge'

# The Problem: OAuth Token Hell

When you're trying to automate Claude Code in isolated environments, you hit this fucking annoying wall: OAuth tokens. Every time you destroy and recreate a VM, you need to re-authenticate Claude Code through a browser. This becomes a nightmare when you're trying to run automated development workflows.

<Alert>
  <AlertDescription>
    Traditional approaches fail because OAuth requires human intervention. You can't script browser authentication flows without getting into security hell.
  </AlertDescription>
</Alert>

I bought this little beast to run my homelab - a Minisforum UN100 with an Intel N100 processor, 16GB RAM, and dual gigabit ethernet ports. Small as fuck but handles everything I throw at it.

![Minisforum UN100](https://darrenwatt.com/content/images/size/w2000/2024/02/Screenshot-2024-02-06-194024.png)

The specs are solid for a homelab starter:
- Intel N100 Processor (4 cores, up to 3.4 GHz)
- 16GB LPDDR5 RAM
- Dual gigabit ethernet (perfect for network testing)
- Multiple HDMI outputs
- Runs at 7.7W idle, 23.5W under load

## The Solution: Persistent VM Pattern

Instead of fighting OAuth complexity, I decided to solve it with infrastructure. The approach is simple: authenticate once, then never destroy the VM.

<Tabs defaultValue="approach">
  <TabsList>
    <TabsTrigger value="approach">The Pattern</TabsTrigger>
    <TabsTrigger value="packer">Packer Phase</TabsTrigger>
    <TabsTrigger value="vagrant">Vagrant Phase</TabsTrigger>
    <TabsTrigger value="benefits">Results</TabsTrigger>
  </TabsList>
  
  <TabsContent value="approach">
    <Card>
      <CardHeader>
        <CardTitle>Two-Phase Infrastructure</CardTitle>
        <CardDescription>Packer builds authenticated images, Vagrant manages runtime</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-2">
          <div>ðŸ“¦ <Badge variant="secondary">Packer</Badge> - One-time image creation with pre-authentication</div>
          <div>ðŸ”„ <Badge variant="secondary">Vagrant</Badge> - Project-specific setup and resource allocation</div>
          <div>ðŸ’¾ <Badge variant="secondary">Suspend/Resume</Badge> - Instead of destroy/recreate cycles</div>
          <div>ðŸ”’ <Badge variant="secondary">Persistent Auth</Badge> - OAuth completed once during image build</div>
        </div>
      </CardContent>
    </Card>
  </TabsContent>
  
  <TabsContent value="packer">
    ```bash
    # Packer handles the heavy lifting
    packer {
      required_plugins {
        virtualbox = {
          version = ">= 1.0.0"
          source  = "github.com/hashicorp/virtualbox"
        }
      }
    }
    
    source "virtualbox-iso" "ubuntu" {
      iso_url      = "ubuntu-20.04.6-live-server-amd64.iso"
      iso_checksum = "sha256:..."
      
      vm_name     = "claude-dev-base"
      memory      = 2048
      cpus        = 2
      disk_size   = 20480
    }
    
    build {
      sources = ["source.virtualbox-iso.ubuntu"]
      
      provisioner "shell" {
        inline = [
          "curl -sSL https://claude.ai/install.sh | bash",
          "claude auth login",  # This requires human interaction
          "/workspace/vm-foreman/mark-authenticated.sh"
        ]
      }
    }
    ```
  </TabsContent>
  
  <TabsContent value="vagrant">
    ```ruby
    # Vagrant uses the pre-built image
    Vagrant.configure("2") do |config|
      config.vm.box = "claude-dev-authenticated"
      config.vm.network "private_network", ip: "192.168.121.44"
      
      config.vm.provider "virtualbox" do |vb|
        vb.memory = "2048"
        vb.cpus = 2
      end
      
      # Project-specific setup only
      config.vm.provision "shell", inline: <<-SHELL
        mkdir -p /workspace/#{project_name}
        cd /workspace && ./setup-project.sh #{project_name}
      SHELL
    end
    ```
  </TabsContent>
  
  <TabsContent value="benefits">
    <div className="grid grid-cols-2 gap-4">
      <Card>
        <CardHeader>
          <CardTitle>Performance</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-2">
            <div><Badge>5-10min</Badge> First-time image build</div>
            <div><Badge>30sec</Badge> Resume time for daily work</div>
            <div><Badge>5sec</Badge> Suspend when done</div>
          </div>
        </CardContent>
      </Card>
      
      <Card>
        <CardHeader>
          <CardTitle>Reliability</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-2">
            <div><Badge>Zero</Badge> Authentication failures</div>
            <div><Badge>100%</Badge> Automation reliability</div>
            <div><Badge>Isolated</Badge> Development environment</div>
          </div>
        </CardContent>
      </Card>
    </div>
  </TabsContent>
</Tabs>

## Implementation Details

The workflow splits into two distinct phases:

### Phase 1: Image Creation (Packer)
```bash
# Build the authenticated base image
packer build claude-dev.pkr.hcl

# This creates a VirtualBox image with:
# - Ubuntu 20.04 base system
# - Claude Code installed and authenticated
# - Development tools pre-configured
# - Authentication token stored securely
```

### Phase 2: Project Management (Vagrant)
```bash
# Daily usage is simple
vagrant up      # Boots from authenticated image
vagrant ssh     # Jump into development environment
# ... do development work ...
vagrant suspend # Saves state, releases resources
```

## Network Setup with Tailscale

Since I'm running this on my homelab, I use Tailscale for secure remote access and Cloudflare for public applications. The VM gets a static IP on the Tailscale network, making it accessible from anywhere.

```bash
# On the VM
sudo tailscale up --ssh
# Now accessible from any device on my Tailscale network
```

## Learning Through Automation

This is my first real homelab setup, and I'm learning the ins and outs of computing as I go. Having Claude Code as an operator makes the learning curve manageable. I can give different Claude instances in different directories their own responsibilities and roles:

- `/workspace/foreman/` - VM orchestration and monitoring
- `/workspace/projects/` - Active development work  
- `/workspace/templates/` - Project templates and scaffolding

Each directory gets its own `CLAUDE.md` file with specific instructions and context.

## The Results

This pattern eliminated OAuth complexity entirely. Instead of fighting authentication flows, I authenticate once during image creation and never deal with it again. The VM suspend/resume cycle takes seconds instead of minutes for full reprovisioning.

For a homelab setup, this approach scales well. I can create multiple authenticated images for different purposes - one for web development, another for systems work, etc. Each image is self-contained and ready to work.

## Implementation Notes

Key decisions that made this work:

1. **Packer for image creation** - Handles the complex OAuth flow once
2. **Vagrant for project management** - Simple, predictable VM lifecycle  
3. **Suspend instead of destroy** - Preserves authentication state
4. **Static networking** - Consistent access patterns
5. **File-based communication** - Simple coordination between host and VM

The Minisforum UN100 handles this workload without breaking a sweat. Power consumption stays low, and the dual ethernet ports let me experiment with network configurations.

This pattern works because it separates concerns properly: Packer handles the hard infrastructure problems, Vagrant handles the simple project management, and the persistent authentication state eliminates the OAuth headache entirely.

<3 Willy out. 